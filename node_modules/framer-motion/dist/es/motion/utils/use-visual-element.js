import { __assign } from 'tslib';
import { useContext, useRef, useEffect } from 'react';
import { MotionConfigContext } from '../context/MotionConfigContext.js';
import { useVisualElementContext } from '../context/MotionContext.js';
import { PresenceContext } from '../../components/AnimatePresence/PresenceContext.js';
import { isPresent } from '../../components/AnimatePresence/use-presence.js';
import { LayoutGroupContext } from '../../components/AnimateSharedLayout/LayoutGroupContext.js';
import { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.js';
import { useSnapshotOnUnmount } from '../features/layout/use-snapshot-on-unmount.js';

function useLayoutId(_a) {
    var layoutId = _a.layoutId;
    var layoutGroupId = useContext(LayoutGroupContext);
    return layoutGroupId && layoutId !== undefined
        ? layoutGroupId + "-" + layoutId
        : layoutId;
}
function useVisualElement(createVisualElement, props, isStatic, ref) {
    var config = useContext(MotionConfigContext);
    var parent = useVisualElementContext();
    var presenceContext = useContext(PresenceContext);
    var layoutId = useLayoutId(props);
    var visualElementRef = useRef(null);
    if (isStatic && visualElementRef.current) {
        /**
         * Clear the VisualElement state in static mode after the initial render.
         * This will allow the VisualElement to render every render as if its the first,
         * with no history. This is basically a cheaper way of reinstantiating the VisualElement
         * every render.
         */
        visualElementRef.current.clearState(props);
    }
    else if (!visualElementRef.current) {
        visualElementRef.current = createVisualElement(isStatic, {
            parent: parent,
            ref: ref,
            isStatic: isStatic,
            props: __assign(__assign({}, props), { layoutId: layoutId }),
            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
        });
    }
    var visualElement = visualElementRef.current;
    useIsomorphicLayoutEffect(function () {
        visualElement.setProps(__assign(__assign(__assign({}, config), props), { layoutId: layoutId }));
        visualElement.isPresent = isPresent(presenceContext);
        visualElement.isPresenceRoot =
            !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);
        /**
         * Fire a render to ensure the latest state is reflected on-screen.
         */
        if (!visualElement.isStatic)
            visualElement.syncRender();
    });
    /**
     * Don't fire unnecessary effects if this is a static component.
     */
    if (isStatic)
        return visualElement;
    useEffect(function () {
        var _a;
        /**
         * In a future refactor we can replace the features-as-components and
         * have this loop through them all firing "effect" listeners
         */
        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();
    });
    /**
     * If this component is a child of AnimateSharedLayout, we need to snapshot the component
     * before it's unmounted. This lives here rather than in features/layout/Measure because
     * as a child component its unmount effect runs after this component has been unmounted.
     */
    useSnapshotOnUnmount(visualElement);
    return visualElement;
}

export { useVisualElement };
